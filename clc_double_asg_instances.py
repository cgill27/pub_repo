#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
clc_double_asg_instances.py

Description:
This script will double, in increments, the number of instances min/desired in an autoscale group

Python external requirements:  (see clc_double_asg_instances_requirements.txt file)
External script requirements:  (none)

If you need to create a requirements file manually, put the below in file (clc_double_asg_instances_requirements.txt):
awscli
argparse
pyfiglet
boto3
termcolor
requests

To install clc_double_asg_instances.py requirements execute: sudo pip install --upgrade -r clc_double_asg_instances_requirements.txt

Written June 2019 by Craig Gill

"""

# Wrap modules that may not be installed by default in try's
try:
    import argparse
except ImportError:
    print "Module 'argparse' not installed! Exiting script"
    quit(2)
try:
    from pyfiglet import Figlet
    figlet_installed = True
except ImportError:
    figlet_installed = False
try:  # Try to use the latest version of Boto3
    import boto3
    from botocore.exceptions import *
except ImportError:
    print "Module 'boto3' not installed! Exiting script"
    quit(2)
try:
    from termcolor import colored
except ImportError:
    print "Module 'termcolor' not installed! Exiting script"
    quit(2)
try:
    import requests
except ImportError:
    print "Module 'requests' not installed! Exiting script"
    quit(2)
# Modules below are usually built-in and do not need to be installed
import os
import sys
import logging
import time
import datetime
import re
import subprocess
import shlex

# Check Python version and exit if not at least 2.7
req_version = (2, 7)
cur_version = os.sys.version_info

if not cur_version >= req_version:
    print "Your Python interpreter is too old. Please consider upgrading to at least Python 2.7"
    quit(2)

# If False then no logs are created, only the status at the end is displayed
debug = True

# If True logs are also printed to screen
print_log = False

# Get name, path, version of this script
script_name = __file__
script_path = os.path.dirname(os.path.abspath(__file__))

# Get Python binary executable path (for calling other python scripts later)
python_bin = sys.executable


def printhelp():
    # Show help options
    if figlet_installed is True:
        f = Figlet(font='slant')
        print f.renderText(script_name)
    print " "
    print "This script will double, in increments, the number of instances min/desired in an autoscale group"
    print " "
    print "Example usage:"
    print "Usage0: %s" % script_name
    print "Usage1: %s -a <autoscale group name>" % script_name
    print "Usage2: %s -a <autoscale group name> -w 60 -s ScheduledActions" % script_name
    print "Usage3: %s -a <autoscale group name> -r <region>" % script_name
    print "Usage4: %s -a <autoscale group name> -p <aws profile name>" % script_name
    print "Usage5: %s -a <autoscale group name> -r <region> -p <aws profile name>" % script_name
    print " "
    print "Required args:"
    print "-a | --asg           Autoscale group name"
    print " "
    print "Optional args:"
    print "-w | --wait          Amount of time in seconds to wait between increasing the ASG Desired/Min count (default: 60 seconds)"
    print "-s | --suspend       Suspend specified process (default: 'ScheduledActions')"
    print "-p | --profile       AWS profile name (generated by 'aws configure'), IAM role used if profile not specified"
    print "-r | --region        Specify AWS region (default: us-east-1)"
    print "-d | --debuglevel    Level of logging (debug, info, warning, error, critical)"
    print "-l | --debuglog      Log file to log to (full path)"
    print "-v | --version       Show script version info"
    print "Note: if 'TIMESTAMP' is in debugLog file name, it will be substituted with a timestamp"
    print "Note2: 'debug = True' must be set in script for logging to happen"
    print " "
    print "Help: %s -h" % script_name
    print " "
    quit(1)


# Parse cli options
parser = argparse.ArgumentParser(description="This script is helpful for connecting to AWS EC2 instances, returns a list of instances in the account")
#   Optional args
parser.add_argument("-a", "--asg", type=str, help="Specify an autoscale group name")
parser.add_argument("-w", "--wait", type=str, help="Specify a wait time in between scaling events in seconds")
parser.add_argument("-s", "--suspend", type=str, help="Specify an action to suspend in the ASG")
parser.add_argument("-p", "--profile", type=str, help="AWS profile name (generated by 'aws configure'), IAM role used if profile not specified")
parser.add_argument("-r", "--region", type=str, help="Specify AWS region (default: us-east-1)")
parser.add_argument("-d", "--debugLevel", type=str, choices=["debug", "info", "warning", "error", "critical"], help="Set debug level")
parser.add_argument("-l", "--debugLog", type=str, help="Debug log file name if debugLevel is set")
# Check for help argument and print help
if "-h" in sys.argv or "--help" in sys.argv or "/h" in sys.argv or "/?" in sys.argv:
    printhelp()
# Print help if we don't have all the required args
if len(sys.argv) < 2:
    printhelp()
args = parser.parse_args()

# Required arg, get autoscale group name
if hasattr(args, "asg") and args.asg is not None:
    if args.asg == "":
        print " "
        print "Required argument 'asg' missing!"
        printhelp()
    if args.asg:
        asg_name = args.asg
        asg_name = asg_name.strip()
    else:
        print " "
        print "Required argument 'asg' missing!"
        printhelp()
else:
    print " "
    print "Required argument 'asg' missing!"
    printhelp()
if args.asg == "":
    print " "
    print "Required argument 'asg' missing!"
    printhelp()

# Optional arg, get number of seconds to wait in between increasing min/desired capacity in increments
wait_seconds_set = False
if hasattr(args, "wait") and args.wait is not None:
    wait_seconds = args.wait
    wait_seconds = wait_seconds.strip()
    wait_seconds = int(wait_seconds)
    wait_seconds_set = True
else:
    wait_seconds = 60

# Optional arg, get process to suspend so scheduled scaling events are suspended, default 'ScheduledActions'
suspend_process_set = False
if hasattr(args, "suspend") and args.suspend is not None:
    suspend_process = args.suspend
    suspend_process = suspend_process.strip()
    suspend_process_set = True
else:
    suspend_process = 'ScheduledActions'

# Optional arg, get aws profile to connect with or use 'default' in aws credentials file ~/.aws/credentials, IAM role used if not specified
profile_region_set = False
if hasattr(args, "profile") and args.profile is not None:
    aws_profile = args.profile
    aws_profile = aws_profile.strip()
    profile_region_set = True
else:
    aws_profile = ""

# Optional arg, get aws region to connect with or use 'us-east-1' as default
#   If profile_region_set and below region_set are False then region will be determined
#   by HTTP GET of EC2 instance metadata
region_set = False
if hasattr(args, "region") and args.region is not None:
    aws_region = args.region
    aws_region = aws_region.strip()
    region_set = True
else:
    aws_region = "us-east-1"

# Optional arg, setup logging if specified at cli
debuglevelSpecified = False
if hasattr(args, "debugLevel") and args.debugLevel is not None:
    debugLevel = args.debugLevel
    debugLevel = debugLevel.strip()
    debuglevelSpecified = True
    if hasattr(args, "debugLog"):
        debugLog = args.debugLog
        debugLog = str(debugLog)
        debugLog = debugLog.strip()
        if debugLog.find(
                "TIMESTAMP") > 0:  # If the word 'TIMESTAMP' is found in debugLog argument, replace with debugLog_suffix
            # https://docs.python.org/2/library/time.html
            debugLog_suffix = datetime.now().strftime(
                "%Y%m%d%H%M%S")  # 20130101235959  year month day hour minute second
            debugLog = debugLog.replace("TIMESTAMP", debugLog_suffix)
        debugLogDir = os.path.dirname(os.path.abspath(debugLog))
        if not os.path.isdir(debugLogDir):
            print "Option 'debugLog' needs to specify full path to a log file!  Exiting script"
            printhelp()
    else:
        print "If specifying debugLevel, also specify debugLog!  Exiting script"
        printhelp()
    debugLevelOptions = ["debug", "info", "warning", "error", "critical"]
    if debugLevel in debugLevelOptions:
        if debugLevel == "debug":
            logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(levelname)s %(message)s', filename=debugLog,
                                filemode='a')
        elif debugLevel == "info":
            logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s', filename=debugLog,
                                filemode='a')
        elif debugLevel == "warning":
            logging.basicConfig(level=logging.WARNING, format='%(asctime)s %(levelname)s %(message)s',
                                filename=debugLog, filemode='a')
        elif debugLevel == "error":
            logging.basicConfig(level=logging.ERROR, format='%(asctime)s %(levelname)s %(message)s', filename=debugLog,
                                filemode='a')
        elif debugLevel == "critical":
            logging.basicConfig(level=logging.CRITICAL, format='%(asctime)s %(levelname)s %(message)s',
                                filename=debugLog, filemode='a')
    else:
        print "Option 'debugLevel' needs to be one of [debug, info, warning, error, critical]!  Exiting script"
        printhelp()
    loggingEnabled = True
else:
    loggingEnabled = False
    debugLevel = ""
    debugLog = ""


def logger(log, level="debug"):
    """ Log to debugLog if logging enabled """
    if loggingEnabled and debug:  # Only log if debugging set to True (top of this script) and debug level/log are set at the cli
        if print_log is True:
            print level + ": %s" % log
        if level == "debug":
            logging.debug(log)
        if level == "info":
            logging.info(log)
        if level == "warning":
            logging.warning(log)
        if level == "error":
            logging.error(log)
        if level == "critical":
            logging.critical(log)
        return True
    else:
        return False


# Get region and other meta data from HTTP GET to EC2 meta data url if no region cli option specified
#   *Note: This url will timeout on non-EC2 instances so you will need to specify the --region cli option
if profile_region_set is False and region_set is False:
    try:
        r = requests.get("http://169.254.169.254/latest/dynamic/instance-identity/document", timeout=3)
    except requests.exceptions.RequestException as err:
        logger("HTTP GET region failed! Error: %s  Exiting script (Use --region argument to manually specify region)" % err, "critical")
        printstring = "HTTP GET region failed! Error: %s  Exiting script (Use --region argument to manually specify region)" % err
        print("{0}".format(colored(printstring, 'red')))
        quit(2)
    if r.status_code == 200:
        response_json = r.json()
        aws_region = response_json.get('region')
        aws_az = response_json.get('availabilityZone')
        my_instanceid = response_json.get('instanceId')
        aws_account = response_json.get('accountId')
    else:
        logger("HTTP GET region failed!  HTTP status code: %s  Exiting script (Use --region argument to manually specify region)" % r.status_code, "critical")
        printstring = "HTTP GET region failed!  HTTP status code: %s  Exiting script (Use --region argument to manually specify region)" % r.status_code
        print("{0}".format(colored(printstring, 'red')))
        quit(2)
    try:
        # Get network internface mac address - needed to get vpc id
        r = requests.get("http://169.254.169.254/latest/meta-data/network/interfaces/macs/", timeout=3)
    except requests.exceptions.RequestException as err:
        logger("HTTP GET mac address failed! Error: %s  Exiting script (Use --region argument to manually specify region)" % err, "warning")
        printstring = "HTTP GET mac address failed! Error: %s  Exiting script (Use --region argument to manually specify region)" % err
        print("{0}".format(colored(printstring, 'red')))
    if r.status_code == 200:
        mac_address = str(r.text)
        mac_address = mac_address.strip("/")
        try:
            # Get vpc id
            r = requests.get("http://169.254.169.254/latest/meta-data/network/interfaces/macs/%s/vpc-id" % mac_address, timeout=3)
        except requests.exceptions.RequestException as err:
            logger("HTTP GET vpc id failed! Error: %s" % err, "warning")
            printstring = "HTTP GET vpc id failed! Error: %s" % err
            print("{0}".format(colored(printstring, 'red')))
        if r.status_code == 200:
            bastion_vpc_id = str(r.text)
        else:
            logger("HTTP GET vpc id failed! HTTP status code: %s" % r.status_code, "warning")
            printstring = "HTTP GET vpc id failed! HTTP status code: %s" % r.status_code
            print("{0}".format(colored(printstring, 'red')))
    else:
        logger("HTTP GET mac address failed! HTTP status code: %s" % r.status_code, "warning")
        printstring = "HTTP GET mac address failed! HTTP status code: %s" % r.status_code
        print("{0}".format(colored(printstring, 'red')))


# Start the log file if logging specified
logger(" ", "info")
script_start_time = time.time()
time_string = datetime.datetime.fromtimestamp(script_start_time)
time_string = time_string.strftime('%Y-%m-%d %H:%M:%S')
logger("--+** Starting '%s' script at %s **+--" % (script_name, time_string), "info")
logger("script_path = '%s'" % script_path, "debug")
if debugLevel is not "":
    logger("debugLevel = '%s'" % debugLevel, "debug")
if debugLog is not "":
    logger("debugLog = '%s'" % debugLog, "debug")
logger("AWS autoscale group name specified = '%s'" % asg_name, "debug")
logger("AWS profile specified = '%s'" % aws_profile, "debug")
if profile_region_set is False and region_set is False:
    logger("AWS region (from HTTP GET metadata url) = '%s'" % aws_region, "debug")
    logger("AWS availabilityZone (from HTTP GET metadata url) = '%s'" % aws_az, "debug")
    logger("AWS account (from HTTP GET metadata url) = '%s'" % aws_account, "debug")
    logger("AWS instanceId (from HTTP GET metadata url) = '%s'" % my_instanceid, "debug")
    logger("Bastion vpc id (from HTTP GET metadata url) = '%s'" % bastion_vpc_id, "debug")
else:
    logger("AWS region specified (default) = '%s'" % aws_region, "debug")


# Create AWS api session with either provided profile account or no account (IAM role used)
try:
    if aws_profile is not "":
        session = boto3.Session(profile_name=aws_profile)
    else:
        session = boto3.Session()
except ProfileNotFound as err:
    logger("AWS Profile '%s' not found! Error: %s   Exiting script" % (aws_profile, err), "critical")
    printstring = "AWS Profile '%s' not found! Error: %s   Exiting script" % (aws_profile, err)
    print("{0}".format(colored(printstring, 'red')))
    quit(2)


# Create AWS Boto3 client
try:
    asg_client = boto3.client("autoscaling", region_name=aws_region)
except EndpointConnectionError as err:
    logger("Unable to connect to AWS autoscaling api in specified region '%s'! Error: %s   Exiting script" % (aws_region, err), "critical")
    printstring = "Unable to connect to AWS autoscaling api in specified region '%s'! Error: %s   Exiting script" % (aws_region, err)
    print("{0}".format(colored(printstring, 'red')))
    quit(2)


# Autoscale group name list
source_asg = []
source_asg.append(asg_name)


def get_asg_settings(autoscaling_group_name):
    try:
        auto_scale_group = asg_client.describe_auto_scaling_groups(AutoScalingGroupNames=autoscaling_group_name)
    except ClientError as err:
        logger("Boto3 autoscaling describe_auto_scaling_groups invalid parameter  Error: %s   Exiting script" % err, "critical")
        printstring = "Boto3 autoscaling describe_auto_scaling_groups invalid parameter  Error: %s   Exiting script" % err
        print("{0}".format(colored(printstring, 'red')))
        quit(2)
    except TypeError as err:
        logger("Boto3 autoscaling describe_auto_scaling_groups TypeError  Error: %s   Exiting script" % err, "critical")
        printstring = "Boto3 autoscaling describe_auto_scaling_groups TypeError  Error: %s   Exiting script" % err
        print("{0}".format(colored(printstring, 'red')))
        quit(2)

    if len(auto_scale_group['AutoScalingGroups']) == 0:
        print "No autoscale group found!"
        quit(2)
    if len(auto_scale_group['AutoScalingGroups']) > 1:
        print "Greater than 1 autoscale group returned"
        quit(2)
    if len(auto_scale_group['AutoScalingGroups']) == 1:
        print("Found ASG: %s" % asg_name)
        for asg in auto_scale_group['AutoScalingGroups']:
            print("Current 'Desired Capacity' setting: %s" % asg['DesiredCapacity'])
            print("Current 'Min' setting: %s" % asg['MinSize'])
            print("Current 'Max' setting: %s" % asg['MaxSize'])
            if len(asg['SuspendedProcesses']) > 0:
                for suspended in asg['SuspendedProcesses']:
                    print("Current 'Suspended Processes' setting: %s" % asg['SuspendedProcesses'])
            else:
                print("No currently suspended processes")
        return asg['MinSize'], asg['MaxSize'], asg['DesiredCapacity'], asg['SuspendedProcesses']


def update_asg_settings(autoscaling_group_name, min_setting, max_setting, desired_setting):
    try:
        response = asg_client.update_auto_scaling_group(AutoScalingGroupName=autoscaling_group_name, MinSize=min_setting, MaxSize=max_setting, DesiredCapacity=desired_setting)
    except ClientError as err:
        logger("Boto3 autoscaling describe_auto_scaling_groups invalid parameter  Error: %s   Exiting script" % err, "critical")
        printstring = "Boto3 autoscaling describe_auto_scaling_groups invalid parameter  Error: %s   Exiting script" % err
        print("{0}".format(colored(printstring, 'red')))
        quit(2)
    except ParamValidationError as err:
        logger("Boto3 parameter validation error  Error: %s   Exiting script" % err, "critical")
        printstring = "Boto3 parameter validation error  Error: %s   Exiting script" % err
        print("{0}".format(colored(printstring, 'red')))
        quit(2)
    print response

print("Getting current settings for ASG: %s" % asg_name)
current_asg_min, current_asg_max, current_asg_desired, current_suspended_procs = get_asg_settings(source_asg)

double_asg_min = current_asg_min * 2
double_asg_desired = current_asg_desired * 2


#update_asg_settings(asg_name, 2, 4, 2)
#get_asg_settings(source_asg)
quit(0)

